#!/usr/bin/env python3
"""
Delete every node_modules directory that has not been accessed
(read or written) in the last 21 days.

Usage:
    python cleanup_node_modules.py [--dry-run] [start-dir]

    --dry-run    Show what would be deleted without touching anything
    start-dir    Directory to start the search in (default: current working dir)
"""

import argparse
import os
import shutil
from datetime import datetime, timedelta
from pathlib import Path


def last_access_time(path: Path) -> float:
    """
    Return the most recent access time (atime) for *path* in seconds
    since the epoch.  Falls back to mtime if atime is not available.
    """
    stat = path.stat()
    return max(stat.st_atime, stat.st_mtime)


def human_size(num_bytes: int) -> str:
    """Return a human-readable size string."""
    for unit in ("B", "KB", "MB", "GB"):
        if num_bytes < 1024:
            return f"{num_bytes:.1f} {unit}"
        num_bytes /= 1024
    return f"{num_bytes:.1f} TB"


def collect_node_modules(root: Path, cutoff_epoch: float):
    """
    Yield (directory_path, last_access_epoch, total_size_bytes) tuples
    for every node_modules directory under *root* whose last access
    time is older than *cutoff_epoch*.
    """
    for dirpath, dirnames, _ in os.walk(root, topdown=True):
        # Prune hidden directories and node_modules itself while descending
        dirnames[:] = [d for d in dirnames if not d.startswith(".")]

        if "node_modules" in dirnames:
            nm_path = Path(dirpath) / "node_modules"
            last_access = last_access_time(nm_path)
            if last_access < cutoff_epoch:
                size = sum(
                    (f.stat().st_size for f in nm_path.rglob("*") if f.is_file()),
                    start=0,
                )
                yield nm_path, last_access, size


def main():
    parser = argparse.ArgumentParser(
        description="Remove stale node_modules directories (unused for 3 weeks)."
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print what would be deleted without removing anything.",
    )
    parser.add_argument(
        "start_dir",
        nargs="?",
        default=".",
        help="Directory to start searching from (default: current directory).",
    )
    args = parser.parse_args()

    root = Path(args.start_dir).resolve()
    if not root.exists():
        parser.error(f"Start directory does not exist: {root}")

    three_weeks_ago = datetime.now() - timedelta(weeks=3)
    cutoff_epoch = three_weeks_ago.timestamp()

    stale_dirs = list(collect_node_modules(root, cutoff_epoch))
    if not stale_dirs:
        print("No stale node_modules directories found.")
        return

    total_size = 0
    for nm_path, last_access, size in stale_dirs:
        total_size += size
        last_access_str = datetime.fromtimestamp(last_access).strftime("%Y-%m-%d %H:%M")
        print(
            f"{'[DRY-RUN] ' if args.dry_run else ''}"
            f"DELETE: {nm_path}  |  last used: {last_access_str}  |  size: {human_size(size)}"
        )

    print(f"\nTotal reclaimed space: {human_size(total_size)}")
    if args.dry_run:
        print("Dry-run complete; nothing was deleted.")
        return

    for nm_path, _, _ in stale_dirs:
        try:
            shutil.rmtree(nm_path)
        except Exception as exc:
            print(f"Error deleting {nm_path}: {exc}")

    print("Cleanup finished.")


if __name__ == "__main__":
    main()
